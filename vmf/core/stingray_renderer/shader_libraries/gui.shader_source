includes = ["core/stingray_renderer/shader_libraries/common.shader_source"]

render_states = {
	gui_gradient = {
		inherits = "opacity"
		states = {
			z_enable = "false"
			z_write_enable = "false"
			defined_WRITE_MASK = {
				defined_ADDITIVE_BLEND = {
					blend_enable = "true"
					blend_op = "blend_op_add"
					dest_blend = "blend_one"
					src_blend = "blend_one"
				}
				ndefined_ADDITIVE_BLEND = {
					blend_enable = "false"
				}
				write_mask0 = "red"
			}
			defined_MASKED = {
				blend_enable = "true"
				blend_op = "blend_op_add"
				dest_blend = "blend_inv_src_alpha"
				src_blend = "blend_src_alpha"
			}
		}
	}
}

hlsl_shaders = {
	gui_gradient = {
		includes = [ "common" ]

		samplers = {
			defined_DIFFUSE_MAP = {
				defined_ATLAS_COLOR_LOOKUP = {
					defined_ANISOTROPIC = {
						diffuse_map = { sampler_states = "clamp_anisotropic" }
					}
					ndefined_ANISOTROPIC = {
						diffuse_map = { sampler_states = "clamp_point" }
					}
				}
				ndefined_ATLAS_COLOR_LOOKUP = {
					defined_CLAMP_POINT ={
						diffuse_map = { sampler_states = "clamp_point" }
					}
					ndefined_CLAMP_POINT = {
						diffuse_map = { sampler_states = "clamp_linear" }
					}
				}
			}
			defined_DIFFUSE_MAP_TWO = {
				diffuse_map = { sampler_states = "clamp_linear" }
				diffuse_map_two = { sampler_states = "clamp_linear" }
			}
			defined_DIFFUSE_MAP_THREE = {
				diffuse_map = { sampler_states = "clamp_linear" }
				diffuse_map_two = { sampler_states = "clamp_linear" }
				diffuse_map_three = { sampler_states = "clamp_linear" }
			}
			defined_DIFFUSE_MAP_FOUR = {
				diffuse_map = { sampler_states = "clamp_linear" }
				diffuse_map_two = { sampler_states = "clamp_linear" }
				diffuse_map_three = { sampler_states = "clamp_linear" }
				diffuse_map_four = { sampler_states = "clamp_linear" }
			}
			defined_DIFFUSE_MAP_FIVE = {
				diffuse_map = { sampler_states = "clamp_linear" }
				diffuse_map_two = { sampler_states = "clamp_linear" }
				diffuse_map_three = { sampler_states = "clamp_linear" }
				diffuse_map_four = { sampler_states = "clamp_linear" }
				diffuse_map_five = { sampler_states = "clamp_linear" }
			}
			defined_DIFFUSE_MAP_SIX = {
				diffuse_map = { sampler_states = "clamp_linear" }
				diffuse_map_two = { sampler_states = "clamp_linear" }
				diffuse_map_three = { sampler_states = "clamp_linear" }
				diffuse_map_four = { sampler_states = "clamp_linear" }
				diffuse_map_five = { sampler_states = "clamp_linear" }
				diffuse_map_six = { sampler_states = "clamp_linear" }
			}
			defined_GRADIENT = {
				gradient_map = { sampler_states = "clamp_anisotropic" }
			}
			defined_MASKED = {
				overlay_mask = { sampler_states = "clamp_point" }
			}
			defined_PATTERN_TINTING = {
				color_atlas = { sampler_states = "clamp_point" }
				material_map = { sampler_states = "clamp_point" }
			}
			defined_DETAIL_TEXTURE = {
				detail_texture = { sampler_states = "wrap_linear" }
			}
			defined_COLOR_TINT_MAP = {
				color_tint_map = { sampler_states = "clamp_linear" }
			}
			defined_DISTORTION = {
				distortion_map = { sampler_states = "wrap_linear" }
			}
		}

		code="""
			#if defined(DIFFUSE_MAP) || defined(DIVISION) || defined(PATTERN_TINTING) || defined(ATLAS_COLOR_LOOKUP) || defined(CIRCULAR_MASK) || defined(CIRCULAR_GRADIENT) || defined(DIFFUSE_MAP_TWO) || defined(DIFFUSE_MAP_THREE) || defined(DIFFUSE_MAP_FOUR) || defined(DIFFUSE_MAP_FIVE) || defined(DIFFUSE_MAP_SIX)
				#define UV0
			#endif

			#if defined(MASKED)
				DECLARE_SAMPLER_2D(overlay_mask);
			#endif

			#if defined(DETAIL_TEXTURE)
				DECLARE_SAMPLER_2D(detail_texture); // exports={ name="Detail Map" type="resource" }
			#endif

			#if defined(DIFFUSE_MAP)
				DECLARE_SAMPLER_2D(diffuse_map); // exports={ name="Diffuse Map" type="resource" }
			#endif

			#if defined(DIFFUSE_MAP_TWO)
				DECLARE_SAMPLER_2D(diffuse_map); // exports={ name="Diffuse Map" type="resource" }
				DECLARE_SAMPLER_2D(diffuse_map_two); // exports={ name="Diffuse Map Two" type="resource" }
			#endif

			#if defined(DIFFUSE_MAP_THREE)
				DECLARE_SAMPLER_2D(diffuse_map); // exports={ name="Diffuse Map" type="resource" }
				DECLARE_SAMPLER_2D(diffuse_map_two); // exports={ name="Diffuse Map Two" type="resource" }
				DECLARE_SAMPLER_2D(diffuse_map_three); // exports={ name="Diffuse Map Three" type="resource" }
			#endif

			#if defined(DIFFUSE_MAP_FOUR)
				DECLARE_SAMPLER_2D(diffuse_map); // exports={ name="Diffuse Map" type="resource" }
				DECLARE_SAMPLER_2D(diffuse_map_two); // exports={ name="Diffuse Map Two" type="resource" }
				DECLARE_SAMPLER_2D(diffuse_map_three); // exports={ name="Diffuse Map Three" type="resource" }
				DECLARE_SAMPLER_2D(diffuse_map_four); // exports={ name="Diffuse Map Four" type="resource" }
			#endif

			#if defined(DIFFUSE_MAP_FIVE)
				DECLARE_SAMPLER_2D(diffuse_map); // exports={ name="Diffuse Map" type="resource" }
				DECLARE_SAMPLER_2D(diffuse_map_two); // exports={ name="Diffuse Map Two" type="resource" }
				DECLARE_SAMPLER_2D(diffuse_map_three); // exports={ name="Diffuse Map Three" type="resource" }
				DECLARE_SAMPLER_2D(diffuse_map_four); // exports={ name="Diffuse Map Four" type="resource" }
				DECLARE_SAMPLER_2D(diffuse_map_five); // exports={ name="Diffuse Map Five" type="resource" }
			#endif

			#if defined(DIFFUSE_MAP_SIX)
				DECLARE_SAMPLER_2D(diffuse_map); // exports={ name="Diffuse Map" type="resource" }
				DECLARE_SAMPLER_2D(diffuse_map_two); // exports={ name="Diffuse Map Two" type="resource" }
				DECLARE_SAMPLER_2D(diffuse_map_three); // exports={ name="Diffuse Map Three" type="resource" }
				DECLARE_SAMPLER_2D(diffuse_map_four); // exports={ name="Diffuse Map Four" type="resource" }
				DECLARE_SAMPLER_2D(diffuse_map_five); // exports={ name="Diffuse Map Five" type="resource" }
				DECLARE_SAMPLER_2D(diffuse_map_six); // exports={ name="Diffuse Map Six" type="resource" }
			#endif

			#if defined(GRADIENT)
				DECLARE_SAMPLER_2D(gradient_map); // exports={ name="Gradient Map" type="resource" }
			#endif

			#if defined(DISTORTION)
				DECLARE_SAMPLER_2D(distortion_map); // exports={ name="Distortion Map" type="resource" }
			#endif

			#if defined(PATTERN_TINTING)
				DECLARE_SAMPLER_2D(color_atlas); // exports={ name="Color Atlas" type="resource" }
				DECLARE_SAMPLER_2D(material_map); // exports={ name="Material Map" type="resource" }
			#endif

			#if defined(COLOR_TINT_MAP)
				DECLARE_SAMPLER_2D(color_tint_map); // exports={ name="Color Tint Map" type="resource" }
			#endif

			struct VS_INPUT {
				float4 position : POSITION;
				#if defined(DIFFUSE_MAP_TWO) || defined(DIFFUSE_MAP_THREE) || defined(DIFFUSE_MAP_FOUR) || defined(DIFFUSE_MAP_FIVE) || defined(DIFFUSE_MAP_SIX) 
					float3 normal : NORMAL;
				#endif
				float4 color : COLOR;
				#if defined(UV0)
					float2 uv : TEXCOORD0;
				#endif
			};

			struct PS_INPUT {
				float4 position : SV_POSITION;
				float4 color : COLOR;
				#if defined(DIFFUSE_MAP_TWO) || defined(DIFFUSE_MAP_THREE) || defined(DIFFUSE_MAP_FOUR) || defined(DIFFUSE_MAP_FIVE) || defined(DIFFUSE_MAP_SIX) 
					float page : TEXCOORD1;
				#endif
				#if defined(UV0)
					float2 uv : TEXCOORD0;
				#endif
			};

			inline float2 scale_material_uv( float2 material_uv, float pattern_variation ) {
				float pattern_u = fmod(pattern_variation,2.0f) * 0.5f;
				float pattern_v = floor(pattern_variation / 2.0f) * 0.5;
				return float2((material_uv.x * 0.5) + pattern_u, (material_uv.y * 0.5) + pattern_v);
			}

			inline float2 scale_uv_coat_of_arms( float2 uv, float variation, float2 atlas_fields ) {
				float step_u = (1.0f/atlas_fields.x);
				float step_v = (1.0f/atlas_fields.y);
				float pattern_u = fmod( variation, atlas_fields.x) * step_u;
				float pattern_v = floor( variation / atlas_fields.x ) * step_v;

				return float2(uv.x * step_u + pattern_u, uv.y * step_v + pattern_v);
			}

			inline float2 scale_uv_coat_of_arms_atlas( float2 uv, float2 offset, float2 scale)
			{
				float2 scaled_uv = uv * scale + offset;
				return scaled_uv;
			}


			CBUFFER_START(c0)
				float4x4 world_view_proj;
				float threshold_fade; // exports = { name="Threshold Fade" type="scalar" value=0.05 min=0.0 max=1 step=0.001 }
				#if defined(GRADIENT)
					float gradient_threshold; // exports = { Name="Gradient threshold" type="scalar" value=0.37 min=0 max=1 step=0.00001 }
				#endif
				#if defined(PATTERN_TINTING)
					float pattern_variation; // exports = { name="Pattern Variation" type="scalar" value=0.0 min=0.0 max=3.0 step=1.0 }
					float atlas_variation; // exports = { name="Armour Atlas Variation" type="scalar" value=0.0 min=0.0 max=31.0 step=1.0 }
					float use_grayscale = 0;
				#endif
				#if defined(ATLAS_COLOR_LOOKUP)
					float2 atlas_tiles; // exports = { name="Atlas tiles" type="vector2" value=[128.0 1.0] min=[1.0 1.0] max=[255.0 255.0] step=[1.0 1.0] }
				#endif
				#if defined(CIRCULAR_MASK)
					float radial_threshold; // exports = { name="Radial Threshold" type="scalar" value=0.5 min=0.0 max=1.0 step=0.0001 }
					float fade_threshold; // exports = { name="Fade Threshold" type="scalar" value=0.5 min=0.0001 max=1.0 step=0.0001 }
					#if defined(UV_SCALE)
						float2 uv_scale; // exports = { name="UV Scale" type="vector2" value=[0.0 0.0] min=[0.001 0.001] max=[1 1] step=[0.0001 0.0001] }
					#endif
				#endif
				#if defined(CIRCULAR_GRADIENT)
					float4 from_color; // exports = { name="Gradient From Color" type="vector4" value=[0.0 0.0 0.0 0.0] min=[0 0 0 0] max=[1 1 1 1] step=[0.0001 0.0001 0.0001 0.0001] }
					float4 to_color; // exports = { name="Gradient To Color" type="vector4" value=[0.0 0.0 0.0 0.0] min=[0 0 0 0] max=[1 1 1 1] step=[0.0001 0.0001 0.0001 0.0001] }
					float exponent; // exports = { name="Gradient exponent" type="scalar" value=1 min=0 max=10.0 step=0.0001 }
					float scale; // exports = { name="Gradient scale" type="scalar" value=1 min=0 max=10.0 step=0.0001 }
				#endif
				#if defined(DISTANCE_FIELD)
					float smoothing_denominator; // exports = { name="Smoothing Scale" type="scalar" value=18 min=2 max=100.0 step=0.001 }
					float outline_color;  // exports = { name="Outline Color" type="vector3" value=[0.0 0.0 0.0] min=[0.0 0.0 0.0] max=[1 1 1] step=[0.0001 0.0001 0.0001] }
					float2 min_value;  // exports = { name="Min Outline" type="vector2" value=[0.0 0.0] min=[0.0 0.0] max=[1 1] step=[0.0001 0.0001] }
					float2 max_value;  // exports = { name="Max Outline" type="vector2" value=[0.0 0.0] min=[0.0 0.0] max=[1 1] step=[0.0001 0.0001] }
				#endif
				#if defined(DETAIL_TEXTURE_DIR)
					float2 detail_dir;  // exports = { name="Detail Texture scroll direction" type="vector2" value=[0.0 0.0] min=[-1 -1] max=[1 1] step=[0.0001 0.0001] }
					float detail_speed; // exports = { name="Detail Texture scroll speed" type="scalar" value=0.5 min=0.0 max=10.0 step=0.0001 }
				#endif
				#if defined(DETAIL_TEXTURE)
					float2 sample_tiling;  // exports = { name="Detail Texture Tiling" type="vector2" value=[1.0 1.0] min=[0 0] max=[100 100] step=[0.0001 0.0001] }
					float detail_offset; // exports = { name="Detail Texture color offset" type="scalar" value=0.0 min=-1 max=1 step=0.0001 }
				#endif
				#if defined(COLOR_TINT_MAP)
					float2 color_tint_uv; // exports = { name="Color Tint UV" type="vector2" value=[0.5 0.5] min=[0.0 0.0] max=[1 1] step=[0.0001 0.0001] }
				#endif
				#if defined(DISTORTION)
					float2 distortion_strength; // exports = { name = "Distortion strength" type = "vector2" value=[0.5 0.5] min=[0.0 0.0] max=[10 10] step=[0.0001 0.0001] }
					float2 distortion_speed; // exports = { name = "Distortion speed" type = "vector2" value=[0.0 0.0] min=[-10.0 -10.0] max=[10.0 10.0] step=[0.0001 0.0001] }
					float distortion_offset_top; // exports = { name="Distortion offset top" type="scalar" value=0.0 min=-0 max=1 step=0.0001 }
				#endif
				#if defined(DESATURATION)
					float desaturation; // exports = { name="Desaturation Value" type="scalar" value=0.5 min=0.0 max=1.0 step=0.0001 }
				#endif
			CBUFFER_END

			DEFAULT_ROOT_SIGNATURE_ATTRIBUTE
			PS_INPUT vs_main(VS_INPUT input) {
				PS_INPUT o;
				o.position = mul(input.position, world_view_proj);
				o.color = decode_vertex_color(input.color);
				#if defined(DIFFUSE_MAP_TWO) || defined(DIFFUSE_MAP_THREE) || defined(DIFFUSE_MAP_FOUR) || defined(DIFFUSE_MAP_FIVE) || defined(DIFFUSE_MAP_SIX) 
					o.page = input.normal.z;
				#endif
				#if defined(UV0)
					o.uv = input.uv;
				#endif
				return o;
			}

			float4 sample_diffuse(float2 uv, float page)
			{
				#if !defined(DIFFUSE_MAP) && !defined(DIFFUSE_MAP_TWO) && !defined(DIFFUSE_MAP_THREE) && !defined(DIFFUSE_MAP_FOUR) && !defined(DIFFUSE_MAP_FIVE) && !defined(DIFFUSE_MAP_SIX)
					return float4(0,0,0,0);
				#endif

				
				#if defined(DIFFUSE_MAP) || defined(DIFFUSE_MAP_TWO) || defined(DIFFUSE_MAP_THREE) || defined(DIFFUSE_MAP_FOUR) || defined(DIFFUSE_MAP_FIVE) || defined(DIFFUSE_MAP_SIX)
				[branch]
				if( page == 0)
					return TEX2D(diffuse_map, uv);
				#endif
				#if defined(DIFFUSE_MAP_TWO) || defined(DIFFUSE_MAP_THREE) || defined(DIFFUSE_MAP_FOUR) || defined(DIFFUSE_MAP_FIVE) || defined(DIFFUSE_MAP_SIX)
				else if( page == 1)
					return TEX2D(diffuse_map_two, uv);
				#endif
				#if defined(DIFFUSE_MAP_THREE) || defined(DIFFUSE_MAP_FOUR) || defined(DIFFUSE_MAP_FIVE) || defined(DIFFUSE_MAP_SIX)
				else if( page == 2)
					return TEX2D(diffuse_map_three, uv);
				#endif
				#if defined(DIFFUSE_MAP_FOUR) || defined(DIFFUSE_MAP_FIVE) || defined(DIFFUSE_MAP_SIX)
				else if( page == 3)
					return TEX2D(diffuse_map_four, uv);
				#endif
				#if defined(DIFFUSE_MAP_FIVE) || defined(DIFFUSE_MAP_SIX)
				else if( page == 4)
					return TEX2D(diffuse_map_five, uv);
				#endif
				#if defined(DIFFUSE_MAP_SIX)
				else
					return TEX2D(diffuse_map_six, uv);
				#endif

				return float4(0,0,0,0);
			}
			
			DEFAULT_ROOT_SIGNATURE_ATTRIBUTE
			float4 ps_main(PS_INPUT input) : SV_TARGET0 {
				#if defined(WRITE_MASK)
					#if defined(DIFFUSE_MAP)
						float mask = TEX2D(diffuse_map, input.uv).a;
						#if defined(COLOR_MASK)
							mask *= input.color.a;
						#endif
					#else
						float mask = input.color.a;
					#endif

					#if defined(THRESHOLD_MASK)
						mask = input.color.a > mask ? saturate((input.color.a - mask) / threshold_fade) : 0;
					#endif

					#if defined(ADDITIVE_BLEND)
						return float4(mask, 0, 0, mask);
					#else
						return float4(mask, 0, 0, 0);
					#endif
				#elif defined(DIVISION)
					float intensity = 1.0;
					intensity = pow(max(pow(((input.uv.x * 2.0) - 1.0),2.0), pow(((input.uv.y * 2.0) - 1.0),2.0)),2.0);

					float4 color = input.color;
					color.rgb *= intensity;
					color.a *= intensity;
					return color;
				#elif defined(CLEAR_MASK)
					#if defined(CLEAR_WITH_ALPHA)
						return float4(1,1,1,input.color.a);
					#else
						return float4(1,1,1,1);
					#endif
				#elif defined(CIRCULAR_GRADIENT)
					float2 uv = input.uv;
					float2 offset_uv = uv - float2(0.5,0.5);
					float hypotenuse = sqrt(offset_uv.x * offset_uv.x + offset_uv.y * offset_uv.y);
					return lerp(to_color, from_color, pow(hypotenuse * scale, exponent));
				#else

					float4 c = input.color;
					#if defined(DIFFUSE_MAP) || defined(DIFFUSE_MAP_TWO) || defined(DIFFUSE_MAP_THREE) || defined(DIFFUSE_MAP_FOUR) || defined(DIFFUSE_MAP_FIVE) || defined(DIFFUSE_MAP_SIX)
						#if defined(DISTANCE_FIELD) 
							float smoothing = 1.0/smoothing_denominator;
							#if defined(DIFFUSE_MAP_TWO) || defined(DIFFUSE_MAP_THREE) || defined(DIFFUSE_MAP_FOUR) || defined(DIFFUSE_MAP_FIVE) || defined(DIFFUSE_MAP_SIX)
								float4 diffuse = sample_diffuse(input.uv, input.page);
							#else
								float4 diffuse = TEX2D(diffuse_map, input.uv);
							#endif
							float alpha = smoothstep(0.5 - smoothing, 0.5 + smoothing, diffuse.a);

							float dist_mask = diffuse.a;
							if( dist_mask >= min_value.x && dist_mask <= max_value.y ) {
								float factor = 1.0;
								if( dist_mask <= min_value.y )
									factor = smoothstep(min_value.x, min_value.y, dist_mask);
								else
									factor = smoothstep(max_value.y, max_value.x, dist_mask); 

								float3 color = lerp(diffuse.rgb * c.rgb, outline_color, factor);
								c = float4(color, alpha * c.a);
							}
							else
								c = saturate(float4(diffuse.rgb * c.rgb, alpha * c.a));
						#elif defined(DISTORTION)
							half4 normal_distortion = TEX2D(distortion_map, input.uv + distortion_speed * time);
							half2 distortion = (normal_distortion.xy * 2.0 - 1.0) * clamp(pow(input.uv.y,2) * distortion_offset_top, 0, 1);
							float4 diffuse = TEX2D(diffuse_map, input.uv + distortion * distortion_strength);
							c *= diffuse;
							c.rgb *= length(float2(1.0,1.0) - distortion);
							//c = float4(distortion, 1, 1);
						#else
							#if defined(ATLAS_COLOR_LOOKUP)
								float atlas_index = floor((input.color.a * 255.0f) + 0.5f);
								float2 atlas_uv = scale_uv_coat_of_arms( input.uv, atlas_index , atlas_tiles );
								float4 diffuse = TEX2D( diffuse_map, atlas_uv );
								c.a = 1.0f;
							#else
								float4 diffuse = TEX2D(diffuse_map, input.uv);
							#endif
							#if defined(ONE_BIT_ALPHA)
								one_bit_alpha_mask(diffuse.a, 0.5);
								c.rgb * diffuse.rgb;
							#else
								c *= diffuse;
							#endif

							#if defined(GAMMA_CORRECTED)
								c.rgb = pow(c.rgb, 2.2/gamma);
							#endif
						#endif
					#endif

					#if defined(COLOR_TINT_MAP)
						float3 tint_color = TEX2D(color_tint_map, color_tint_uv).rgb;
						c.rgb *= tint_color;
					#endif

					#if defined(DETAIL_TEXTURE)
						float2 sample_uv = (input.position.xy / back_buffer_size) * sample_tiling;
						#if defined(DETAIL_TEXTURE_DIR)
							float detail_value = TEX2D(detail_texture, sample_uv + detail_dir * detail_speed * time).r;
						#else
							float detail_value = TEX2D(detail_texture, sample_uv).r;
						#endif
						#if defined(MASK_WITH_DETAIL_TEXTURE)
							c.rgba += detail_offset + (detail_value - 0.5);
						#else
							c.rgb += detail_offset + (detail_value - 0.5);
						#endif
					#endif

					#if defined(PATTERN_TINTING)
						//float4 pattern_sample_uv = float4( scale_material_uv( input.uv, pattern_variation ), 0.0f, 0.0f );
						float4 pattern_sample_uv = float4( input.uv, 0.0f, 0.0f );
						float pattern_value = TEX2D( material_map, pattern_sample_uv ).a;

						float4 armour_tint_sample_uv = float4( pattern_value, (atlas_variation / 32.0f), 0.0f, 0.0f);
						half4 armour_tint_color = TEX2D( color_atlas, armour_tint_sample_uv );

						c.rgb *= armour_tint_color.rgb * 2;
						if( use_grayscale )
							c.rgb = (c.r + c.g + c.b) / 3;
					#endif

					#if defined(CIRCULAR_MASK)
						float2 uv = input.uv;
						#if defined(UV_SCALE)
							uv = fmod(input.uv, uv_scale) * floor((1.0/uv_scale) + 0.5);
						#endif
						float2 offset_uv = uv - float2(0.5,0.5);
						float hypotenuse_squared = offset_uv.x * offset_uv.x + offset_uv.y * offset_uv.y;
						float radial_threshold_squared = (radial_threshold * radial_threshold);
						float fade_threshold_squared = (fade_threshold*fade_threshold);
						if( hypotenuse_squared > radial_threshold_squared)
						{
							float diff = hypotenuse_squared - radial_threshold_squared;
							c.a *= lerp(1.0,0.0, diff/fade_threshold_squared);
						}
					#endif

					#if defined(MASKED)
						float2 masked_uv = input.position.xy / back_buffer_size;
						half mask = TEX2D(overlay_mask, masked_uv).r;
						c.a *= mask;
					#endif

					#if defined(RADIAL_DISSOLVE)
						float value = sqrt( pow((input.uv.x * 2.0) - 1.0,2.0) + pow((input.uv.y * 2.0) - 1.0,2.0) );
						if( value < 0.9 )
							c.a *= lerp( 1.0, 0.0, (0.9 - value)/0.4);
					#endif

					#if defined(GRADIENT)
						float4 gradient_value = TEX2D(gradient_map, input.uv);
						if( gradient_value.r > gradient_threshold)
							discard;
					#endif

					#if defined(GRAYSCALE)
						float intensity = (c.r + c.g + c.b) / 3.0f;
						c.rgb = intensity;
					#endif

					#if defined(DESATURATION)
						float intensity = (c.r + c.g + c.b) / 3.0f;
						c.rgb = lerp(c.rgb, float3(intensity, intensity, intensity), desaturation);
					#endif

					return c;
				#endif
			}
		"""
	}
}

shaders = {
	gui_gradient = {
		editor_options = [
			{
				name="Pixel Modifiers"
				options = [
					{ name="Diffuse Map" define="DIFFUSE_MAP" condition="!DIFFUSE_MAP_TWO && !DIFFUSE_MAP_THREE && !DIFFUSE_MAP_FOUR && !DIFFUSE_MAP_FIVE && !DIFFUSE_MAP_SIX" }
					{ name="Gradient Map" define="GRADIENT" }
					{ name="One Bit Alpha" define="ONE_BIT_ALPHA" }
					{ name="Grayscale" define="GRAYSCALE" }
					{ name="Atlas lookup from alpha" define="ATLAS_COLOR_LOOKUP" }
					{ name="- Anisotropic Filtering" defined="ANISOTROPIC" }
					{ name="Circular Gradient" define="CIRCULAR_GRADIENT" }
					{ name="Distance Field" define="DISTANCE_FIELD" }
					{ name="Detail Texture" define="DETAIL_TEXTURE" }
					{ name="Detail Texture scroll direction" define="DETAIL_TEXTURE_DIR" condition="DETAIL_TEXTURE"}
					{ name="Mask with Detail Texture" define="MASK_WITH_DETAIL_TEXTURE" condition="DETAIL_TEXTURE"}
					{ name="Tint Color Map" define="COLOR_TINT_MAP" }
					{ name="Gamma Correction" define="GAMMA_CORRECTED" }
					{ name="Normal Map Distortion" define="DISTORTION" }
					{ name="Desaturation" define="DESATURATION" }
					{ name="Two Font Maps" define="DIFFUSE_MAP_TWO" condition="DISTANCE_FIELD && !DIFFUSE_MAP && !DIFFUSE_MAP_THREE && !DIFFUSE_MAP_FOUR && !DIFFUSE_MAP_FIVE && !DIFFUSE_MAP_SIX" }
					{ name="Three Font Maps" define="DIFFUSE_MAP_THREE" condition="DISTANCE_FIELD && !DIFFUSE_MAP && !DIFFUSE_MAP_TWO && !DIFFUSE_MAP_FOUR && !DIFFUSE_MAP_FIVE && !DIFFUSE_MAP_SIX" }
					{ name="Four Font Maps" define="DIFFUSE_MAP_FOUR" condition="DISTANCE_FIELD && !DIFFUSE_MAP && !DIFFUSE_MAP_THREE && !DIFFUSE_MAP_TWO && !DIFFUSE_MAP_FIVE && !DIFFUSE_MAP_SIX" }
					{ name="Five Font Maps" define="DIFFUSE_MAP_FIVE" condition="DISTANCE_FIELD && !DIFFUSE_MAP && !DIFFUSE_MAP_THREE && !DIFFUSE_MAP_FOUR && !DIFFUSE_MAP_TWO && !DIFFUSE_MAP_SIX" }
					{ name="Six Font Maps" define="DIFFUSE_MAP_SIX" condition="DISTANCE_FIELD && !DIFFUSE_MAP && !DIFFUSE_MAP_THREE && !DIFFUSE_MAP_FOUR && !DIFFUSE_MAP_FIVE && !DIFFUSE_MAP_TWO" }
				]
			}
			{
				name="Masking"
				options = [
					{ name="Write Transparency Mask" define="WRITE_MASK" condition="!MASKED"}
					{ name=" - Additive Blend" define="ADDITIVE_BLEND" condition="WRITE_MASK"}
					{ name="Diffuse and Color Mask" define="COLOR_MASK" condition="WRITE_MASK && DIFFUSE_MAP"}
					{ name="Threshold Mask" define="THRESHOLD_MASK" }
					{ name="Transparency Masked" define="MASKED" condition="!WRITE_MASK && !CLEAR_MASK"}
					{ name="Circular Mask" defined="CIRCULAR_MASK" }
					{ name="- UV Scale" defined="UV_SCALE" }
				]
			}
			{
				name="Depth Testing"
				options = [
					{ name="Depth Testing Enabled" define="DEPTH_TEST_ENABLED" }
				]
			}
		]

		contexts = {
			default = {
				passes = [
					{
						defined = "OES2"
						pass = [
							{ layer="transparent" hlsl_shader="mobile_gui" render_states="gui_gradient" }
						]
						fail = [
							{
								defined = "CLEAR_MASK"
								pass = [
									{ layer="transparent_mask" hlsl_shader="gui_gradient" render_states="gui_gradient" }
								]
								fail = [
									{
										defined = "WRITE_MASK"
										pass = [
											{ layer="transparent_mask" hlsl_shader="gui_gradient" render_states="gui_gradient" }
										]
										fail = [
											{ layer="transparent" hlsl_shader="gui_gradient" render_states="gui_gradient" }
										]
									}
								]
							}
						]
					}
				]
			}
		}

		compile = {
			default = [
				{ defines="" platforms = "D3D11 D3D12 GL2 GNM"}
			]
		}
	}

}

static_compile = [
	{ shader = "gui_gradient" defines = "MASKED" }
	{ shader = "gui_gradient" defines = "DIFFUSE_MAP ANISOTROPIC CIRCULAR_MASK MASKED " }
	{ shader = "gui_gradient" defines = "ATLAS_COLOR_LOOKUP DIFFUSE_MAP" }
	{ shader = "gui_gradient" defines = "DIFFUSE_MAP CIRCULAR_MASK UV_SCALE" }
	{ shader = "gui_gradient" defines = "WRITE_MASK CLEAR_WITH_ALPHA" }
	{ shader = "gui_gradient" defines = "DIFFUSE_MAP PATTERN_TINTING" }
	{ shader = "gui_gradient" defines = "ATLAS_COLOR_LOOKUP DIFFUSE_MAP MASKED ANISOTROPIC" }
	{ shader = "gui_gradient" defines = "DIFFUSE_MAP MASKED" }
	{ shader = "gui_gradient" defines = "DIFFUSE_MAP MATERIAL_TINT_RGB_1 MATERIAL_TINT_RGB_2 MATERIAL_TINT_RGB_3" }
	{ shader = "gui_gradient" defines = "DIFFUSE_MAP MASKED CIRCULAR_MASK UV_SCALE" }
	{ shader = "gui_gradient" defines = "DIFFUSE_MAP PATTERN_TINTING MASKED" }
	{ shader = "gui_gradient" defines = "DIVISION" }
	{ shader = "gui_gradient" defines = "WRITE_MASK" }
	{ shader = "gui_gradient" defines = "ATLAS_COLOR_LOOKUP DIFFUSE_MAP ANISOTROPIC" }
	{ shader = "gui_gradient" defines = "ATLAS_COLOR_LOOKUP DIFFUSE_MAP MASKED" }
	{ shader = "gui_gradient" defines = "DIFFUSE_MAP MASKED GRAYSCALE" }
	{ shader = "gui_gradient" defines = "DIFFUSE_MAP WRITE_MASK" }
	{ shader = "gui_gradient" defines = "DIFFUSE_MAP GRAYSCALE" }
	{ shader = "gui_gradient" defines = "CLEAR_MASK" }
	{ shader = "gui_gradient" defines = "DIFFUSE_MAP" }
	{ shader = "gui_gradient" defines = "DIFFUSE_MAP GRADIENT" }
	{ shader = "gui_gradient" defines = "DIFFUSE_MAP DISTANCE_FIELD" }
	{ shader = "gui_gradient" defines = "DIFFUSE_MAP DISTORTION" }
]
